## 谈谈模块化
 在早期的web时代JS只是为了实现一些简单的页面交互,了了数语即可 ,但随着web2.0时代的到来,ajax技术得到广泛应用,JQ等前端类库层出不穷,
 前端业务日益复杂,越来越多的事情放到前端来做,此处JS的开发者就要考虑使用模块化来管理我们的代码  
 ### 呢么什么是模块化  
 + 将一个复杂的应用按照某种规范拆分成一些块,最终进行组合使用
 + 每个块的内部实现时私有的,隐藏内部细节,给外部暴露API  
 ### 模块的演进历程
 #### 函数封装
 通过吧不同的功能封装在不同的函数中,进行调用的方式实现模块化  
 缺点：  
 + 造成全局变量冲突
 + 无法看出模块之间的依赖关系
 #### 命名空间模式
 通过对象封装解决上述的全局变量冲突问题
 缺点:
 + 使用者可以直接对模块内部的变量进行修改
 #### IIFE模式
 通过函数自执行的方式,隐藏内部细节,暴露API 这也是在当时最常用的模块化规范 类似JQ,lodash等类库早期都是通过这种方式来组织代码  
 缺点    
 + 如果模块之间互相依赖呢么我们就需要有序的引入这些模块不然就会出错,像在早期的JQ时代,使用JQ UI等相关插件往往都需要西安引入JQ
   这种模式就会出现请求过多,依赖模糊,难以维护的问题  
 ## 当下比较流行的模块化
 ### cjs模块
 node中采用cjs模块规范,每个文件是一个模块,模块内部变量私有,向外导出变量,模块与模块之间同步加载
 ####特点
 + 每个模块有自己的作用域,不会污染全局作用域
 + 模块有缓存功能
 + 每个模块导出的是具体值,也可以理解成值的拷贝
 + 模块加载采用同步,有序加载
 ### AMD
 cjs中模块采用同步加载,由于服务端模块加载基本是都是在本地所以比较快但如果直接在浏览器使用这种模块化规范,同步加载会阻塞后面的代码,
 所以在浏览器我们更需要的是采用异步加载,不阻塞后端代码,AMD(require.js)则是采用异步加载以回调函数的方式来执行
 缺点
 + 成本较高,需要手动在配置文件中(main.js)去维护模块路径等
 + 不支持按需加载
 ### CMD
 cmd(sea.js)则是集合了amd和cjs的特点,在支持浏览器异步加载的功能上支持了按需加载等到需要使用的时候再去加载
 ### ESM
 es6模块化设计思想是尽量静态化,使在编译阶段就能确定模块的依赖关系,输入输出的变量
 特点
 + 设计更加静态化,对开发者友好
 + export导出的是API这一点和cjs不同,要注意的是export导出的是变量而不是对象
 + 默认导出的是值的拷贝,当然对于默认导出不建议使用尤其是导出的是一个对象字面量的话这种导出编译之后会把默认导出的变量挂载到exports的
   default属性上,在cjs和esm混用的话会出现问题,一个esm模块默认导出想在cjs模块使用必须引用对应的default属性反之亦然一个cjs模块
   想在esm模块中默认导入必须在cjs的exports属性上挂载default变量才可以正常使用
   并且babel tsc,rollup对它的编译各有不同也就意味着打包工具迁移带来的问题,就像刚刚使用TS的时候正常的默认导入会报错也正是因为tsc和babel
   初期是不兼容的 ts这些模块看成一个个命名空间所以需要 import *这种语法
 + 由于导出的是变量,所以不会存在缓存
 + 要注意的是 es6的模块化实在语言层面上实现了模块化,相对简单完全可以取代cjs cmd等成为浏览器和服务端通用的模块化规范
 

